import {
  Deferred
} from "./chunk-JQTWNC4I.js";
import {
  WorkboxError,
  finalAssertExports,
  logger
} from "./chunk-3XZA232I.js";

// node_modules/workbox-streams/_version.js
try {
  self["workbox:streams:6.5.3"] && _();
} catch (e) {
}

// node_modules/workbox-streams/concatenate.js
function _getReaderFromSource(source) {
  if (source instanceof Response) {
    if (source.body) {
      return source.body.getReader();
    }
    throw new WorkboxError("opaque-streams-source", { type: source.type });
  }
  if (source instanceof ReadableStream) {
    return source.getReader();
  }
  return new Response(source).body.getReader();
}
function concatenate(sourcePromises) {
  if (true) {
    finalAssertExports.isArray(sourcePromises, {
      moduleName: "workbox-streams",
      funcName: "concatenate",
      paramName: "sourcePromises"
    });
  }
  const readerPromises = sourcePromises.map((sourcePromise) => {
    return Promise.resolve(sourcePromise).then((source) => {
      return _getReaderFromSource(source);
    });
  });
  const streamDeferred = new Deferred();
  let i = 0;
  const logMessages = [];
  const stream = new ReadableStream({
    pull(controller) {
      return readerPromises[i].then((reader) => reader.read()).then((result) => {
        if (result.done) {
          if (true) {
            logMessages.push([
              "Reached the end of source:",
              sourcePromises[i]
            ]);
          }
          i++;
          if (i >= readerPromises.length) {
            if (true) {
              logger.groupCollapsed(`Concatenating ${readerPromises.length} sources.`);
              for (const message of logMessages) {
                if (Array.isArray(message)) {
                  logger.log(...message);
                } else {
                  logger.log(message);
                }
              }
              logger.log("Finished reading all sources.");
              logger.groupEnd();
            }
            controller.close();
            streamDeferred.resolve();
            return;
          }
          return this.pull(controller);
        } else {
          controller.enqueue(result.value);
        }
      }).catch((error) => {
        if (true) {
          logger.error("An error occurred:", error);
        }
        streamDeferred.reject(error);
        throw error;
      });
    },
    cancel() {
      if (true) {
        logger.warn("The ReadableStream was cancelled.");
      }
      streamDeferred.resolve();
    }
  });
  return { done: streamDeferred.promise, stream };
}

// node_modules/workbox-streams/utils/createHeaders.js
function createHeaders(headersInit = {}) {
  const headers = new Headers(headersInit);
  if (!headers.has("content-type")) {
    headers.set("content-type", "text/html");
  }
  return headers;
}

// node_modules/workbox-streams/concatenateToResponse.js
function concatenateToResponse(sourcePromises, headersInit) {
  const { done, stream } = concatenate(sourcePromises);
  const headers = createHeaders(headersInit);
  const response = new Response(stream, { headers });
  return { done, response };
}

// node_modules/workbox-core/_private/canConstructReadableStream.js
var supportStatus;
function canConstructReadableStream() {
  if (supportStatus === void 0) {
    try {
      new ReadableStream({ start() {
      } });
      supportStatus = true;
    } catch (error) {
      supportStatus = false;
    }
  }
  return supportStatus;
}

// node_modules/workbox-streams/isSupported.js
function isSupported() {
  return canConstructReadableStream();
}

// node_modules/workbox-streams/strategy.js
function strategy(sourceFunctions, headersInit) {
  return async ({ event, request, url, params }) => {
    const sourcePromises = sourceFunctions.map((fn) => {
      return Promise.resolve(fn({ event, request, url, params }));
    });
    if (isSupported()) {
      const { done, response } = concatenateToResponse(sourcePromises, headersInit);
      if (event) {
        event.waitUntil(done);
      }
      return response;
    }
    if (true) {
      logger.log(`The current browser doesn't support creating response streams. Falling back to non-streaming response instead.`);
    }
    const blobPartsPromises = sourcePromises.map(async (sourcePromise) => {
      const source = await sourcePromise;
      if (source instanceof Response) {
        return source.blob();
      } else {
        return new Response(source).blob();
      }
    });
    const blobParts = await Promise.all(blobPartsPromises);
    const headers = createHeaders(headersInit);
    return new Response(new Blob(blobParts), { headers });
  };
}
export {
  concatenate,
  concatenateToResponse,
  isSupported,
  strategy
};
//# sourceMappingURL=workbox-streams.js.map
