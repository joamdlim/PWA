import {
  getFriendlyURL
} from "./chunk-KAQQHGED.js";
import {
  WorkboxError,
  finalAssertExports,
  logger
} from "./chunk-3XZA232I.js";

// node_modules/workbox-cacheable-response/_version.js
try {
  self["workbox:cacheable-response:6.5.3"] && _();
} catch (e) {
}

// node_modules/workbox-cacheable-response/CacheableResponse.js
var CacheableResponse = class {
  constructor(config = {}) {
    if (true) {
      if (!(config.statuses || config.headers)) {
        throw new WorkboxError("statuses-or-headers-required", {
          moduleName: "workbox-cacheable-response",
          className: "CacheableResponse",
          funcName: "constructor"
        });
      }
      if (config.statuses) {
        finalAssertExports.isArray(config.statuses, {
          moduleName: "workbox-cacheable-response",
          className: "CacheableResponse",
          funcName: "constructor",
          paramName: "config.statuses"
        });
      }
      if (config.headers) {
        finalAssertExports.isType(config.headers, "object", {
          moduleName: "workbox-cacheable-response",
          className: "CacheableResponse",
          funcName: "constructor",
          paramName: "config.headers"
        });
      }
    }
    this._statuses = config.statuses;
    this._headers = config.headers;
  }
  isResponseCacheable(response) {
    if (true) {
      finalAssertExports.isInstance(response, Response, {
        moduleName: "workbox-cacheable-response",
        className: "CacheableResponse",
        funcName: "isResponseCacheable",
        paramName: "response"
      });
    }
    let cacheable = true;
    if (this._statuses) {
      cacheable = this._statuses.includes(response.status);
    }
    if (this._headers && cacheable) {
      cacheable = Object.keys(this._headers).some((headerName) => {
        return response.headers.get(headerName) === this._headers[headerName];
      });
    }
    if (true) {
      if (!cacheable) {
        logger.groupCollapsed(`The request for '${getFriendlyURL(response.url)}' returned a response that does not meet the criteria for being cached.`);
        logger.groupCollapsed(`View cacheability criteria here.`);
        logger.log(`Cacheable statuses: ` + JSON.stringify(this._statuses));
        logger.log(`Cacheable headers: ` + JSON.stringify(this._headers, null, 2));
        logger.groupEnd();
        const logFriendlyHeaders = {};
        response.headers.forEach((value, key) => {
          logFriendlyHeaders[key] = value;
        });
        logger.groupCollapsed(`View response status and headers here.`);
        logger.log(`Response status: ${response.status}`);
        logger.log(`Response headers: ` + JSON.stringify(logFriendlyHeaders, null, 2));
        logger.groupEnd();
        logger.groupCollapsed(`View full response details here.`);
        logger.log(response.headers);
        logger.log(response);
        logger.groupEnd();
        logger.groupEnd();
      }
    }
    return cacheable;
  }
};

// node_modules/workbox-cacheable-response/CacheableResponsePlugin.js
var CacheableResponsePlugin = class {
  constructor(config) {
    this.cacheWillUpdate = async ({ response }) => {
      if (this._cacheableResponse.isResponseCacheable(response)) {
        return response;
      }
      return null;
    };
    this._cacheableResponse = new CacheableResponse(config);
  }
};

export {
  CacheableResponse,
  CacheableResponsePlugin
};
//# sourceMappingURL=chunk-HNVO7BRZ.js.map
