{
  "version": 3,
  "sources": ["../../workbox-streams/_version.js", "../../workbox-streams/concatenate.js", "../../workbox-streams/utils/createHeaders.js", "../../workbox-streams/concatenateToResponse.js", "../../workbox-core/_private/canConstructReadableStream.js", "../../workbox-streams/isSupported.js", "../../workbox-streams/strategy.js"],
  "sourcesContent": ["\"use strict\";\n// @ts-ignore\ntry {\n    self['workbox:streams:6.5.3'] && _();\n}\ncatch (e) { }\n", "/*\n  Copyright 2018 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\nimport { assert } from 'workbox-core/_private/assert.js';\nimport { Deferred } from 'workbox-core/_private/Deferred.js';\nimport { logger } from 'workbox-core/_private/logger.js';\nimport { WorkboxError } from 'workbox-core/_private/WorkboxError.js';\nimport './_version.js';\n/**\n * Takes either a Response, a ReadableStream, or a\n * [BodyInit](https://fetch.spec.whatwg.org/#bodyinit) and returns the\n * ReadableStreamReader object associated with it.\n *\n * @param {workbox-streams.StreamSource} source\n * @return {ReadableStreamReader}\n * @private\n */\nfunction _getReaderFromSource(source) {\n    if (source instanceof Response) {\n        // See https://github.com/GoogleChrome/workbox/issues/2998\n        if (source.body) {\n            return source.body.getReader();\n        }\n        throw new WorkboxError('opaque-streams-source', { type: source.type });\n    }\n    if (source instanceof ReadableStream) {\n        return source.getReader();\n    }\n    return new Response(source).body.getReader();\n}\n/**\n * Takes multiple source Promises, each of which could resolve to a Response, a\n * ReadableStream, or a [BodyInit](https://fetch.spec.whatwg.org/#bodyinit).\n *\n * Returns an object exposing a ReadableStream with each individual stream's\n * data returned in sequence, along with a Promise which signals when the\n * stream is finished (useful for passing to a FetchEvent's waitUntil()).\n *\n * @param {Array<Promise<workbox-streams.StreamSource>>} sourcePromises\n * @return {Object<{done: Promise, stream: ReadableStream}>}\n *\n * @memberof workbox-streams\n */\nfunction concatenate(sourcePromises) {\n    if (process.env.NODE_ENV !== 'production') {\n        assert.isArray(sourcePromises, {\n            moduleName: 'workbox-streams',\n            funcName: 'concatenate',\n            paramName: 'sourcePromises',\n        });\n    }\n    const readerPromises = sourcePromises.map((sourcePromise) => {\n        return Promise.resolve(sourcePromise).then((source) => {\n            return _getReaderFromSource(source);\n        });\n    });\n    const streamDeferred = new Deferred();\n    let i = 0;\n    const logMessages = [];\n    const stream = new ReadableStream({\n        pull(controller) {\n            return readerPromises[i]\n                .then((reader) => reader.read())\n                .then((result) => {\n                if (result.done) {\n                    if (process.env.NODE_ENV !== 'production') {\n                        logMessages.push([\n                            'Reached the end of source:',\n                            sourcePromises[i],\n                        ]);\n                    }\n                    i++;\n                    if (i >= readerPromises.length) {\n                        // Log all the messages in the group at once in a single group.\n                        if (process.env.NODE_ENV !== 'production') {\n                            logger.groupCollapsed(`Concatenating ${readerPromises.length} sources.`);\n                            for (const message of logMessages) {\n                                if (Array.isArray(message)) {\n                                    logger.log(...message);\n                                }\n                                else {\n                                    logger.log(message);\n                                }\n                            }\n                            logger.log('Finished reading all sources.');\n                            logger.groupEnd();\n                        }\n                        controller.close();\n                        streamDeferred.resolve();\n                        return;\n                    }\n                    // The `pull` method is defined because we're inside it.\n                    return this.pull(controller);\n                }\n                else {\n                    controller.enqueue(result.value);\n                }\n            })\n                .catch((error) => {\n                if (process.env.NODE_ENV !== 'production') {\n                    logger.error('An error occurred:', error);\n                }\n                streamDeferred.reject(error);\n                throw error;\n            });\n        },\n        cancel() {\n            if (process.env.NODE_ENV !== 'production') {\n                logger.warn('The ReadableStream was cancelled.');\n            }\n            streamDeferred.resolve();\n        },\n    });\n    return { done: streamDeferred.promise, stream };\n}\nexport { concatenate };\n", "/*\n  Copyright 2018 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\nimport '../_version.js';\n/**\n * This is a utility method that determines whether the current browser supports\n * the features required to create streamed responses. Currently, it checks if\n * [`ReadableStream`](https://developer.mozilla.org/en-US/docs/Web/API/ReadableStream/ReadableStream)\n * is available.\n *\n * @private\n * @param {HeadersInit} [headersInit] If there's no `Content-Type` specified,\n * `'text/html'` will be used by default.\n * @return {boolean} `true`, if the current browser meets the requirements for\n * streaming responses, and `false` otherwise.\n *\n * @memberof workbox-streams\n */\nfunction createHeaders(headersInit = {}) {\n    // See https://github.com/GoogleChrome/workbox/issues/1461\n    const headers = new Headers(headersInit);\n    if (!headers.has('content-type')) {\n        headers.set('content-type', 'text/html');\n    }\n    return headers;\n}\nexport { createHeaders };\n", "/*\n  Copyright 2018 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\nimport { createHeaders } from './utils/createHeaders.js';\nimport { concatenate } from './concatenate.js';\nimport './_version.js';\n/**\n * Takes multiple source Promises, each of which could resolve to a Response, a\n * ReadableStream, or a [BodyInit](https://fetch.spec.whatwg.org/#bodyinit),\n * along with a\n * [HeadersInit](https://fetch.spec.whatwg.org/#typedefdef-headersinit).\n *\n * Returns an object exposing a Response whose body consists of each individual\n * stream's data returned in sequence, along with a Promise which signals when\n * the stream is finished (useful for passing to a FetchEvent's waitUntil()).\n *\n * @param {Array<Promise<workbox-streams.StreamSource>>} sourcePromises\n * @param {HeadersInit} [headersInit] If there's no `Content-Type` specified,\n * `'text/html'` will be used by default.\n * @return {Object<{done: Promise, response: Response}>}\n *\n * @memberof workbox-streams\n */\nfunction concatenateToResponse(sourcePromises, headersInit) {\n    const { done, stream } = concatenate(sourcePromises);\n    const headers = createHeaders(headersInit);\n    const response = new Response(stream, { headers });\n    return { done, response };\n}\nexport { concatenateToResponse };\n", "/*\n  Copyright 2019 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\nimport '../_version.js';\nlet supportStatus;\n/**\n * A utility function that determines whether the current browser supports\n * constructing a [`ReadableStream`](https://developer.mozilla.org/en-US/docs/Web/API/ReadableStream/ReadableStream)\n * object.\n *\n * @return {boolean} `true`, if the current browser can successfully\n *     construct a `ReadableStream`, `false` otherwise.\n *\n * @private\n */\nfunction canConstructReadableStream() {\n    if (supportStatus === undefined) {\n        // See https://github.com/GoogleChrome/workbox/issues/1473\n        try {\n            new ReadableStream({ start() { } });\n            supportStatus = true;\n        }\n        catch (error) {\n            supportStatus = false;\n        }\n    }\n    return supportStatus;\n}\nexport { canConstructReadableStream };\n", "/*\n  Copyright 2018 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\nimport { canConstructReadableStream } from 'workbox-core/_private/canConstructReadableStream.js';\nimport './_version.js';\n/**\n * This is a utility method that determines whether the current browser supports\n * the features required to create streamed responses. Currently, it checks if\n * [`ReadableStream`](https://developer.mozilla.org/en-US/docs/Web/API/ReadableStream/ReadableStream)\n * can be created.\n *\n * @return {boolean} `true`, if the current browser meets the requirements for\n * streaming responses, and `false` otherwise.\n *\n * @memberof workbox-streams\n */\nfunction isSupported() {\n    return canConstructReadableStream();\n}\nexport { isSupported };\n", "/*\n  Copyright 2018 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\nimport { logger } from 'workbox-core/_private/logger.js';\nimport { createHeaders } from './utils/createHeaders.js';\nimport { concatenateToResponse } from './concatenateToResponse.js';\nimport { isSupported } from './isSupported.js';\nimport './_version.js';\n/**\n * A shortcut to create a strategy that could be dropped-in to Workbox's router.\n *\n * On browsers that do not support constructing new `ReadableStream`s, this\n * strategy will automatically wait for all the `sourceFunctions` to complete,\n * and create a final response that concatenates their values together.\n *\n * @param {Array<function({event, request, url, params})>} sourceFunctions\n * An array of functions similar to {@link workbox-routing~handlerCallback}\n * but that instead return a {@link workbox-streams.StreamSource} (or a\n * Promise which resolves to one).\n * @param {HeadersInit} [headersInit] If there's no `Content-Type` specified,\n * `'text/html'` will be used by default.\n * @return {workbox-routing~handlerCallback}\n * @memberof workbox-streams\n */\nfunction strategy(sourceFunctions, headersInit) {\n    return async ({ event, request, url, params }) => {\n        const sourcePromises = sourceFunctions.map((fn) => {\n            // Ensure the return value of the function is always a promise.\n            return Promise.resolve(fn({ event, request, url, params }));\n        });\n        if (isSupported()) {\n            const { done, response } = concatenateToResponse(sourcePromises, headersInit);\n            if (event) {\n                event.waitUntil(done);\n            }\n            return response;\n        }\n        if (process.env.NODE_ENV !== 'production') {\n            logger.log(`The current browser doesn't support creating response ` +\n                `streams. Falling back to non-streaming response instead.`);\n        }\n        // Fallback to waiting for everything to finish, and concatenating the\n        // responses.\n        const blobPartsPromises = sourcePromises.map(async (sourcePromise) => {\n            const source = await sourcePromise;\n            if (source instanceof Response) {\n                return source.blob();\n            }\n            else {\n                // Technically, a `StreamSource` object can include any valid\n                // `BodyInit` type, including `FormData` and `URLSearchParams`, which\n                // cannot be passed to the Blob constructor directly, so we have to\n                // convert them to actual Blobs first.\n                return new Response(source).blob();\n            }\n        });\n        const blobParts = await Promise.all(blobPartsPromises);\n        const headers = createHeaders(headersInit);\n        // Constructing a new Response from a Blob source is well-supported.\n        // So is constructing a new Blob from multiple source Blobs or strings.\n        return new Response(new Blob(blobParts), { headers });\n    };\n}\nexport { strategy };\n"],
  "mappings": "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",
  "names": []
}
